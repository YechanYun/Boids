{"ast":null,"code":"import { sepFactor } from \"./constants\";\nexport class Bird {\n  constructor(initialX, initialY, initialVelX, initialVelY) {\n    this.x = initialX;\n    this.y = initialY;\n    this.velX = initialVelX;\n    this.vely = initialVelY;\n  }\n  keepVelocityInRange() {\n    // doesn't exceed maximum\n    // no divisions by 0, since speed is never 0\n    let max_sf = math.min(maxSpeed / math.sqrt(velX ** 2 + velY ** 2), 1);\n    this.velX *= max_sf;\n    this.velY *= max_sf;\n\n    // ensure velocity doesn't fall below minimum\n    let min_sf = math.max(minSpeed / math.sqrt(velX ** 2 + velY ** 2), 1);\n    this.velX *= min_sf;\n    this.velY *= min_sf;\n  }\n  separate(nearbyBirds) {\n    let close_dx = 0;\n    let close_dy = 0;\n    nearbyBirds.foreach(b => {\n      close_dx += this.x - b.x;\n      close_dy += this.y - b.y;\n    });\n    /*\n    (close_dx, close_dy) match {\n      case (0, 0) => {}\n      case (dx, 0) => this.velX += sepFactor / close_dx\n      case (0, dy) => this.velY += sepFactor / close_dy\n      case (dx, dy) => {\n        this.velX += sepFactor / close_dx // careful of / 0\n        this.velY += sepFactor / close_dy\n      }\n    }\n      */\n    if (close_dx != 0) {\n      this.velX += sepFactor / close_dx;\n    }\n    if (close_dy != 0) {\n      this.velY += sepFactor / close_dy;\n    }\n    keepVelocityWithinRange();\n  }\n  align(nearbyBirds) {\n    if (nearbyBirds.size > 0) {\n      const {\n        sumVelX,\n        sumVelY\n      } = nearbyBirds.reduce((acc, b) => ({\n        sumVelX: acc.sumVelX + b.velX,\n        sumVelY: acc.sumVelY + b.velY\n      }), {\n        sumVelX: 0,\n        sumVelY: 0\n      });\n      let avgVelX = sumVelX / nearbyBirds.size;\n      let avgVelY = sumVelY / nearbyBirds.size;\n      this.velX += (avgVelX - this.velX) * alignFactor;\n      this.velY += (avgVelY - this.velY) * alignFactor;\n    }\n    keepVelocityWithinRange();\n  }\n  cohere(nearbyBirds) {\n    // condition avoids division by 0\n    if (nearbyBirds.size > 0) {\n      /*\n      let (sumCentreX, sumCentreY) = nearbyBirds.map(\n      b => (b.x, b.y)\n      ).reduce(\n      (b1, b2) => (b1._1 + b2._1, b1._2 + b2._2)\n      )\n      */\n\n      const {\n        sumX,\n        sumY\n      } = nearbyBirds.reduce((acc, b) => ({\n        sumX: acc.sumX + b.x,\n        sumY: acc.sumY + b.y\n      }), {\n        sumX: 0,\n        sumY: 0\n      });\n      let avgX = sumX / nearbyBirds.size;\n      let avgY = sumY / nearbyBirds.size;\n      this.velX += (avgX - this.x) * cohesionFactor;\n      this.velY += (avgY - this.y) * cohesionFactor;\n    }\n    keepVelocityWithinRange();\n  }\n  screenTurn(nearbyBirds) {\n    if (x < leftRightMargin) {\n      velX += turnFactor;\n    } else if (x > CANVAS_WIDTH - leftRightMargin) {\n      velX -= turnFactor;\n    }\n    if (y < topBottomMargin) {\n      velY += turnFactor;\n    } else if (y < CANVAS_HEIGHT - topBottomMargin) {\n      velY -= turnFactor;\n    }\n  }\n  update(time) {\n    let _x = x + velX * time;\n    let _y = y + velY * time;\n\n    // _x = _x.max(RADIUS.value).min(CANVAS_WIDTH - RADIUS.value)\n    // _y = _y.max(RADIUS.value).min(CANVAS_HEIGHT - RADIUS.value)\n\n    if (_x < RADIUS) {\n      _x = CANVAS_WIDTH - (RADIUS - _x);\n    } else if (_x > CANVAS_WIDTH - RADIUS) {\n      _x = _x - (CANVAS_WIDTH - RADIUS);\n    }\n    if (_y < RADIUS) {\n      _y = CANVAS_HEIGHT - (RADIUS - _y);\n    } else if (_y > CANVAS_HEIGHT - RADIUS) {\n      _y = _y - (CANVAS_HEIGHT - RADIUS);\n    }\n    centerX.value = _x;\n    centerY.value = _y;\n  }\n}","map":{"version":3,"names":["sepFactor","Bird","constructor","initialX","initialY","initialVelX","initialVelY","x","y","velX","vely","keepVelocityInRange","max_sf","math","min","maxSpeed","sqrt","velY","min_sf","max","minSpeed","separate","nearbyBirds","close_dx","close_dy","foreach","b","keepVelocityWithinRange","align","size","sumVelX","sumVelY","reduce","acc","avgVelX","avgVelY","alignFactor","cohere","sumX","sumY","avgX","avgY","cohesionFactor","screenTurn","leftRightMargin","turnFactor","CANVAS_WIDTH","topBottomMargin","CANVAS_HEIGHT","update","time","_x","_y","RADIUS","centerX","value","centerY"],"sources":["/home/yechan/imperial/side_projects/birds-flocking/src/Bird.js"],"sourcesContent":["import { sepFactor } from \"./constants\"\n\nexport class Bird {\n    constructor(initialX, initialY, initialVelX,initialVelY) {\n        this.x = initialX\n        this.y = initialY\n        this.velX = initialVelX\n        this.vely = initialVelY\n    }\n\n    keepVelocityInRange() {\n        // doesn't exceed maximum\n        // no divisions by 0, since speed is never 0\n        let max_sf = math.min(maxSpeed / math.sqrt(velX ** 2 + velY ** 2), 1)\n        this.velX *= max_sf\n        this.velY *= max_sf\n\n        // ensure velocity doesn't fall below minimum\n        let min_sf = math.max(minSpeed / math.sqrt(velX ** 2 + velY ** 2), 1)\n        this.velX *= min_sf\n        this.velY *= min_sf\n    }\n\n    separate(nearbyBirds) {\n        let close_dx = 0\n        let close_dy = 0\n        nearbyBirds.foreach(\n          b =>\n          {\n            close_dx += this.x - b.x\n            close_dy += this.y - b.y\n          }\n        )\n        /*\n        (close_dx, close_dy) match {\n          case (0, 0) => {}\n          case (dx, 0) => this.velX += sepFactor / close_dx\n          case (0, dy) => this.velY += sepFactor / close_dy\n          case (dx, dy) => {\n            this.velX += sepFactor / close_dx // careful of / 0\n            this.velY += sepFactor / close_dy\n          }\n        }\n          */\n        if (close_dx != 0) {\n            this.velX += sepFactor / close_dx\n        }\n        if (close_dy != 0) {\n            this.velY += sepFactor / close_dy\n        }\n        keepVelocityWithinRange()\n    }\n\n    align(nearbyBirds) {\n        if (nearbyBirds.size > 0) {\n\n            const { sumVelX, sumVelY } = nearbyBirds.reduce(\n                (acc, b) => ({\n                    sumVelX: acc.sumVelX + b.velX,\n                    sumVelY: acc.sumVelY + b.velY\n                }), { sumVelX: 0, sumVelY: 0 }\n            )\n            \n            let avgVelX = sumVelX / nearbyBirds.size\n            let avgVelY = sumVelY / nearbyBirds.size\n      \n\n            this.velX += (avgVelX - this.velX) * alignFactor\n            this.velY += (avgVelY - this.velY) * alignFactor\n          }\n          keepVelocityWithinRange()\n    }\n\n    cohere(nearbyBirds) {\n\n        // condition avoids division by 0\n        if (nearbyBirds.size > 0) {\n            /*\n            let (sumCentreX, sumCentreY) = nearbyBirds.map(\n            b => (b.x, b.y)\n            ).reduce(\n            (b1, b2) => (b1._1 + b2._1, b1._2 + b2._2)\n            )\n            */\n\n            const { sumX, sumY } = nearbyBirds.reduce(\n                (acc, b) => ({\n                    sumX: acc.sumX + b.x,\n                    sumY: acc.sumY + b.y\n                }), { sumX: 0, sumY: 0 }\n            )\n\n            let avgX = sumX / nearbyBirds.size\n            let avgY = sumY / nearbyBirds.size\n    \n            this.velX += (avgX - this.x) * cohesionFactor\n            this.velY += (avgY - this.y) * cohesionFactor\n        }\n        keepVelocityWithinRange()\n    }\n\n    screenTurn(nearbyBirds) {\n        if (x < leftRightMargin) {\n            velX += turnFactor\n          } else if (x > CANVAS_WIDTH - leftRightMargin) {\n            velX -= turnFactor\n          }\n          if (y < topBottomMargin) {\n            velY += turnFactor\n          } else if (y < CANVAS_HEIGHT - topBottomMargin) {\n            velY -= turnFactor\n          }\n    }\n\n    update(time) {\n        let _x = x + velX * time\n        let _y = y + velY * time\n    \n        // _x = _x.max(RADIUS.value).min(CANVAS_WIDTH - RADIUS.value)\n        // _y = _y.max(RADIUS.value).min(CANVAS_HEIGHT - RADIUS.value)\n    \n        if (_x < RADIUS) {\n          _x = CANVAS_WIDTH - (RADIUS - _x)\n        } else if (_x > CANVAS_WIDTH - RADIUS) {\n          _x = _x - (CANVAS_WIDTH - RADIUS)\n        }\n    \n        if (_y < RADIUS) {\n          _y = CANVAS_HEIGHT - (RADIUS - _y)\n        } else if (_y > CANVAS_HEIGHT - RADIUS) {\n          _y = _y - (CANVAS_HEIGHT - RADIUS)\n        }\n    \n        centerX.value = _x\n        centerY.value = _y\n    }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}