{"ast":null,"code":"import { CANVAS_HEIGHT, CANVAS_WIDTH, leftRightMargin, topBottomMargin, maxSpeed, minSpeed, RADIUS } from \"./constants\";\nexport class Bird {\n  constructor(initialX, initialY, initialVelX, initialVelY) {\n    this.x = initialX;\n    this.y = initialY;\n    this.velX = initialVelX;\n    this.velY = initialVelY;\n  }\n  keepVelocityWithinRange() {\n    // doesn't exceed maximum\n    // no divisions by 0, since speed is never 0\n    let max_sf = Math.min(maxSpeed / Math.sqrt(this.velX ** 2 + this.velY ** 2), 1);\n    this.velX *= max_sf;\n    this.velY *= max_sf;\n\n    // ensure velocity doesn't fall below minimum\n    let min_sf = Math.max(minSpeed / Math.sqrt(this.velX ** 2 + this.velY ** 2), 1);\n    this.velX *= min_sf;\n    this.velY *= min_sf;\n  }\n  separate(nearbyBirds, sepFactor) {\n    let close_dx = 0;\n    let close_dy = 0;\n    nearbyBirds.forEach(b => {\n      close_dx += this.x - b.x;\n      close_dy += this.y - b.y;\n    });\n    if (close_dx !== 0) {\n      this.velX += sepFactor / close_dx;\n    }\n    if (close_dy !== 0) {\n      this.velY += sepFactor / close_dy;\n    }\n    this.keepVelocityWithinRange();\n  }\n  align(nearbyBirds, alignFactor) {\n    //console.log(\"just outside if for align\")\n    if (nearbyBirds.size > 0) {\n      //console.log(\"INSIDE ALIGN, \", typeof nearbyBirds)\n      //console.log(nearbyBirds)\n      const {\n        sumVelX,\n        sumVelY\n      } = Array.from(nearbyBirds).reduce((acc, b) => ({\n        sumVelX: acc.sumVelX + b.velX,\n        sumVelY: acc.sumVelY + b.velY\n      }), {\n        sumVelX: 0,\n        sumVelY: 0\n      });\n      let avgVelX = sumVelX / nearbyBirds.size;\n      let avgVelY = sumVelY / nearbyBirds.size;\n      this.velX += (avgVelX - this.velX) * alignFactor;\n      this.velY += (avgVelY - this.velY) * alignFactor;\n    }\n    this.keepVelocityWithinRange();\n  }\n  cohere(nearbyBirds, cohesionFactor) {\n    // condition avoids division by 0\n    if (nearbyBirds.size > 0) {\n      const {\n        sumX,\n        sumY\n      } = Array.from(nearbyBirds).reduce((acc, b) => ({\n        sumX: acc.sumX + b.x,\n        sumY: acc.sumY + b.y\n      }), {\n        sumX: 0,\n        sumY: 0\n      });\n      let avgX = sumX / nearbyBirds.size;\n      let avgY = sumY / nearbyBirds.size;\n      this.velX += (avgX - this.x) * cohesionFactor;\n      this.velY += (avgY - this.y) * cohesionFactor;\n    }\n    this.keepVelocityWithinRange();\n  }\n  screenTurn(turnFactor) {\n    if (this.x < leftRightMargin) {\n      this.velX += turnFactor;\n    } else if (this.x > CANVAS_WIDTH - leftRightMargin) {\n      this.velX -= turnFactor;\n    }\n    if (this.y < topBottomMargin) {\n      this.velY += turnFactor;\n    } else if (this.y > CANVAS_HEIGHT - topBottomMargin) {\n      this.velY -= turnFactor;\n    }\n  }\n  update(time) {\n    let _x = this.x + this.velX * time;\n    let _y = this.y + this.velY * time;\n\n    // _x = _x.max(RADIUS.value).min(CANVAS_WIDTH - RADIUS.value)\n    // _y = _y.max(RADIUS.value).min(CANVAS_HEIGHT - RADIUS.value)\n\n    if (_x < RADIUS) {\n      _x = CANVAS_WIDTH - (RADIUS - _x);\n    } else if (_x > CANVAS_WIDTH - RADIUS) {\n      _x = _x - (CANVAS_WIDTH - RADIUS);\n    }\n    if (_y < RADIUS) {\n      _y = CANVAS_HEIGHT - (RADIUS - _y);\n    } else if (_y > CANVAS_HEIGHT - RADIUS) {\n      _y = _y - (CANVAS_HEIGHT - RADIUS);\n    }\n    this.x = _x;\n    this.y = _y;\n  }\n}","map":{"version":3,"names":["CANVAS_HEIGHT","CANVAS_WIDTH","leftRightMargin","topBottomMargin","maxSpeed","minSpeed","RADIUS","Bird","constructor","initialX","initialY","initialVelX","initialVelY","x","y","velX","velY","keepVelocityWithinRange","max_sf","Math","min","sqrt","min_sf","max","separate","nearbyBirds","sepFactor","close_dx","close_dy","forEach","b","align","alignFactor","size","sumVelX","sumVelY","Array","from","reduce","acc","avgVelX","avgVelY","cohere","cohesionFactor","sumX","sumY","avgX","avgY","screenTurn","turnFactor","update","time","_x","_y"],"sources":["/home/yechan/imperial/side_projects/birds-flocking/src/Bird.js"],"sourcesContent":["import {\n    CANVAS_HEIGHT,\n    CANVAS_WIDTH,\n    leftRightMargin,\n    topBottomMargin,\n    maxSpeed,\n    minSpeed,\n    RADIUS,\n} from \"./constants\"\n\nexport class Bird {\n    constructor(initialX, initialY, initialVelX,initialVelY) {\n        this.x = initialX\n        this.y = initialY\n        this.velX = initialVelX\n        this.velY = initialVelY\n    }\n\n    keepVelocityWithinRange() {\n        // doesn't exceed maximum\n        // no divisions by 0, since speed is never 0\n        let max_sf = Math.min(maxSpeed / Math.sqrt(this.velX ** 2 + this.velY ** 2), 1)\n        this.velX *= max_sf\n        this.velY *= max_sf\n\n        // ensure velocity doesn't fall below minimum\n        let min_sf = Math.max(minSpeed / Math.sqrt(this.velX ** 2 + this.velY ** 2), 1)\n        this.velX *= min_sf\n        this.velY *= min_sf\n    }\n\n    separate(nearbyBirds, sepFactor) {\n        let close_dx = 0\n        let close_dy = 0\n        nearbyBirds.forEach(\n          b =>\n          {\n            close_dx += this.x - b.x\n            close_dy += this.y - b.y\n          }\n        )\n\n        if (close_dx !== 0) {\n            this.velX += sepFactor / close_dx\n        }\n        if (close_dy !== 0) {\n            this.velY += sepFactor / close_dy\n        }\n        this.keepVelocityWithinRange()\n    }\n\n    align(nearbyBirds, alignFactor) {\n        //console.log(\"just outside if for align\")\n        if (nearbyBirds.size > 0) {\n            //console.log(\"INSIDE ALIGN, \", typeof nearbyBirds)\n            //console.log(nearbyBirds)\n            const { sumVelX, sumVelY } = Array.from(nearbyBirds).reduce(\n                (acc, b) => ({\n                    sumVelX: acc.sumVelX + b.velX,\n                    sumVelY: acc.sumVelY + b.velY\n                }), { sumVelX: 0, sumVelY: 0 }\n            )\n            \n            let avgVelX = sumVelX / nearbyBirds.size\n            let avgVelY = sumVelY / nearbyBirds.size\n      \n\n            this.velX += (avgVelX - this.velX) * alignFactor\n            this.velY += (avgVelY - this.velY) * alignFactor\n          }\n          this.keepVelocityWithinRange()\n    }\n\n    cohere(nearbyBirds, cohesionFactor) {\n\n        // condition avoids division by 0\n        if (nearbyBirds.size > 0) {\n        \n            const { sumX, sumY } = Array.from(nearbyBirds).reduce(\n                (acc, b) => ({\n                    sumX: acc.sumX + b.x,\n                    sumY: acc.sumY + b.y\n                }), { sumX: 0, sumY: 0 }\n            )\n\n            let avgX = sumX / nearbyBirds.size\n            let avgY = sumY / nearbyBirds.size\n    \n            this.velX += (avgX - this.x) * cohesionFactor\n            this.velY += (avgY - this.y) * cohesionFactor\n        }\n        this.keepVelocityWithinRange()\n    }\n\n    screenTurn(turnFactor) {\n        if (this.x < leftRightMargin) {\n            this.velX += turnFactor\n          } else if (this.x > CANVAS_WIDTH - leftRightMargin) {\n            this.velX -= turnFactor\n          }\n        if (this.y < topBottomMargin) {\n          this.velY += turnFactor\n        } else if (this.y > CANVAS_HEIGHT - topBottomMargin) {\n          this.velY -= turnFactor\n        }\n    }\n\n    update(time) {\n        let _x = this.x + this.velX * time\n        let _y = this.y + this.velY * time\n    \n        // _x = _x.max(RADIUS.value).min(CANVAS_WIDTH - RADIUS.value)\n        // _y = _y.max(RADIUS.value).min(CANVAS_HEIGHT - RADIUS.value)\n    \n        if (_x < RADIUS) {\n          _x = CANVAS_WIDTH - (RADIUS - _x)\n        } else if (_x > CANVAS_WIDTH - RADIUS) {\n          _x = _x - (CANVAS_WIDTH - RADIUS)\n        }\n    \n        if (_y < RADIUS) {\n          _y = CANVAS_HEIGHT - (RADIUS - _y)\n        } else if (_y > CANVAS_HEIGHT - RADIUS) {\n          _y = _y - (CANVAS_HEIGHT - RADIUS)\n        }\n    \n        this.x = _x\n        this.y = _y\n    }\n}"],"mappings":"AAAA,SACIA,aAAa,EACbC,YAAY,EACZC,eAAe,EACfC,eAAe,EACfC,QAAQ,EACRC,QAAQ,EACRC,MAAM,QACH,aAAa;AAEpB,OAAO,MAAMC,IAAI,CAAC;EACdC,WAAWA,CAACC,QAAQ,EAAEC,QAAQ,EAAEC,WAAW,EAACC,WAAW,EAAE;IACrD,IAAI,CAACC,CAAC,GAAGJ,QAAQ;IACjB,IAAI,CAACK,CAAC,GAAGJ,QAAQ;IACjB,IAAI,CAACK,IAAI,GAAGJ,WAAW;IACvB,IAAI,CAACK,IAAI,GAAGJ,WAAW;EAC3B;EAEAK,uBAAuBA,CAAA,EAAG;IACtB;IACA;IACA,IAAIC,MAAM,GAAGC,IAAI,CAACC,GAAG,CAAChB,QAAQ,GAAGe,IAAI,CAACE,IAAI,CAAC,IAAI,CAACN,IAAI,IAAI,CAAC,GAAG,IAAI,CAACC,IAAI,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC;IAC/E,IAAI,CAACD,IAAI,IAAIG,MAAM;IACnB,IAAI,CAACF,IAAI,IAAIE,MAAM;;IAEnB;IACA,IAAII,MAAM,GAAGH,IAAI,CAACI,GAAG,CAAClB,QAAQ,GAAGc,IAAI,CAACE,IAAI,CAAC,IAAI,CAACN,IAAI,IAAI,CAAC,GAAG,IAAI,CAACC,IAAI,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC;IAC/E,IAAI,CAACD,IAAI,IAAIO,MAAM;IACnB,IAAI,CAACN,IAAI,IAAIM,MAAM;EACvB;EAEAE,QAAQA,CAACC,WAAW,EAAEC,SAAS,EAAE;IAC7B,IAAIC,QAAQ,GAAG,CAAC;IAChB,IAAIC,QAAQ,GAAG,CAAC;IAChBH,WAAW,CAACI,OAAO,CACjBC,CAAC,IACD;MACEH,QAAQ,IAAI,IAAI,CAACd,CAAC,GAAGiB,CAAC,CAACjB,CAAC;MACxBe,QAAQ,IAAI,IAAI,CAACd,CAAC,GAAGgB,CAAC,CAAChB,CAAC;IAC1B,CACF,CAAC;IAED,IAAIa,QAAQ,KAAK,CAAC,EAAE;MAChB,IAAI,CAACZ,IAAI,IAAIW,SAAS,GAAGC,QAAQ;IACrC;IACA,IAAIC,QAAQ,KAAK,CAAC,EAAE;MAChB,IAAI,CAACZ,IAAI,IAAIU,SAAS,GAAGE,QAAQ;IACrC;IACA,IAAI,CAACX,uBAAuB,CAAC,CAAC;EAClC;EAEAc,KAAKA,CAACN,WAAW,EAAEO,WAAW,EAAE;IAC5B;IACA,IAAIP,WAAW,CAACQ,IAAI,GAAG,CAAC,EAAE;MACtB;MACA;MACA,MAAM;QAAEC,OAAO;QAAEC;MAAQ,CAAC,GAAGC,KAAK,CAACC,IAAI,CAACZ,WAAW,CAAC,CAACa,MAAM,CACvD,CAACC,GAAG,EAAET,CAAC,MAAM;QACTI,OAAO,EAAEK,GAAG,CAACL,OAAO,GAAGJ,CAAC,CAACf,IAAI;QAC7BoB,OAAO,EAAEI,GAAG,CAACJ,OAAO,GAAGL,CAAC,CAACd;MAC7B,CAAC,CAAC,EAAE;QAAEkB,OAAO,EAAE,CAAC;QAAEC,OAAO,EAAE;MAAE,CACjC,CAAC;MAED,IAAIK,OAAO,GAAGN,OAAO,GAAGT,WAAW,CAACQ,IAAI;MACxC,IAAIQ,OAAO,GAAGN,OAAO,GAAGV,WAAW,CAACQ,IAAI;MAGxC,IAAI,CAAClB,IAAI,IAAI,CAACyB,OAAO,GAAG,IAAI,CAACzB,IAAI,IAAIiB,WAAW;MAChD,IAAI,CAAChB,IAAI,IAAI,CAACyB,OAAO,GAAG,IAAI,CAACzB,IAAI,IAAIgB,WAAW;IAClD;IACA,IAAI,CAACf,uBAAuB,CAAC,CAAC;EACpC;EAEAyB,MAAMA,CAACjB,WAAW,EAAEkB,cAAc,EAAE;IAEhC;IACA,IAAIlB,WAAW,CAACQ,IAAI,GAAG,CAAC,EAAE;MAEtB,MAAM;QAAEW,IAAI;QAAEC;MAAK,CAAC,GAAGT,KAAK,CAACC,IAAI,CAACZ,WAAW,CAAC,CAACa,MAAM,CACjD,CAACC,GAAG,EAAET,CAAC,MAAM;QACTc,IAAI,EAAEL,GAAG,CAACK,IAAI,GAAGd,CAAC,CAACjB,CAAC;QACpBgC,IAAI,EAAEN,GAAG,CAACM,IAAI,GAAGf,CAAC,CAAChB;MACvB,CAAC,CAAC,EAAE;QAAE8B,IAAI,EAAE,CAAC;QAAEC,IAAI,EAAE;MAAE,CAC3B,CAAC;MAED,IAAIC,IAAI,GAAGF,IAAI,GAAGnB,WAAW,CAACQ,IAAI;MAClC,IAAIc,IAAI,GAAGF,IAAI,GAAGpB,WAAW,CAACQ,IAAI;MAElC,IAAI,CAAClB,IAAI,IAAI,CAAC+B,IAAI,GAAG,IAAI,CAACjC,CAAC,IAAI8B,cAAc;MAC7C,IAAI,CAAC3B,IAAI,IAAI,CAAC+B,IAAI,GAAG,IAAI,CAACjC,CAAC,IAAI6B,cAAc;IACjD;IACA,IAAI,CAAC1B,uBAAuB,CAAC,CAAC;EAClC;EAEA+B,UAAUA,CAACC,UAAU,EAAE;IACnB,IAAI,IAAI,CAACpC,CAAC,GAAGX,eAAe,EAAE;MAC1B,IAAI,CAACa,IAAI,IAAIkC,UAAU;IACzB,CAAC,MAAM,IAAI,IAAI,CAACpC,CAAC,GAAGZ,YAAY,GAAGC,eAAe,EAAE;MAClD,IAAI,CAACa,IAAI,IAAIkC,UAAU;IACzB;IACF,IAAI,IAAI,CAACnC,CAAC,GAAGX,eAAe,EAAE;MAC5B,IAAI,CAACa,IAAI,IAAIiC,UAAU;IACzB,CAAC,MAAM,IAAI,IAAI,CAACnC,CAAC,GAAGd,aAAa,GAAGG,eAAe,EAAE;MACnD,IAAI,CAACa,IAAI,IAAIiC,UAAU;IACzB;EACJ;EAEAC,MAAMA,CAACC,IAAI,EAAE;IACT,IAAIC,EAAE,GAAG,IAAI,CAACvC,CAAC,GAAG,IAAI,CAACE,IAAI,GAAGoC,IAAI;IAClC,IAAIE,EAAE,GAAG,IAAI,CAACvC,CAAC,GAAG,IAAI,CAACE,IAAI,GAAGmC,IAAI;;IAElC;IACA;;IAEA,IAAIC,EAAE,GAAG9C,MAAM,EAAE;MACf8C,EAAE,GAAGnD,YAAY,IAAIK,MAAM,GAAG8C,EAAE,CAAC;IACnC,CAAC,MAAM,IAAIA,EAAE,GAAGnD,YAAY,GAAGK,MAAM,EAAE;MACrC8C,EAAE,GAAGA,EAAE,IAAInD,YAAY,GAAGK,MAAM,CAAC;IACnC;IAEA,IAAI+C,EAAE,GAAG/C,MAAM,EAAE;MACf+C,EAAE,GAAGrD,aAAa,IAAIM,MAAM,GAAG+C,EAAE,CAAC;IACpC,CAAC,MAAM,IAAIA,EAAE,GAAGrD,aAAa,GAAGM,MAAM,EAAE;MACtC+C,EAAE,GAAGA,EAAE,IAAIrD,aAAa,GAAGM,MAAM,CAAC;IACpC;IAEA,IAAI,CAACO,CAAC,GAAGuC,EAAE;IACX,IAAI,CAACtC,CAAC,GAAGuC,EAAE;EACf;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}